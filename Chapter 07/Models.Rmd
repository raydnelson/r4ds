---
title: "Diamond Price Prediction"
author: "Ray Nelson"
date: "10/4/2018"
output:
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(modelr)
library(tidyverse)
```

## Sample from our tibble

Since our tibble has approximately 54,000 observations, we will first draw a random sample of 1000. This lays the ground work for when we partition our tibble into a training set and a testing set. It is also the basis for bootstrapping and jacknifing.

```{r diamonds2}
set.seed(1234) # Needed so all get the sample random choice of observations
diamonds2 <- diamonds %>% sample_n(1000)
```  

## First Step Scatterplot: Initial assessment of linear relationship and constant variance

```{r first scatterplot, messages = FALSE}
diamonds2 %>% ggplot(aes(x = carat, y = price)) +
  geom_point() +
  geom_smooth(method = "loess", color = "red") +
  geom_smooth(method = "lm", color = "blue") +
  labs(
    title = "Check for Linearity and Constant Variance",
    subtitle = "Simple Regression versus Locally Weighted Scatterplot Smoother",
    x = "Weight in Carats",
    y = "Price in Dollars"
  )
```  

Our data exploration reveals that we have a linear relationship between price and diamond size. It also introduces the challenge that the variation in the price increases as the weight of the diamond increases.  

## Look for relationships between price versus clarity, color, and cut

### Clarity

First let's look at the distribution of clarity in our sample.  

```{r clarity distribution}
diamonds2 %>% count(clarity)
```  
Notice that the most desirable clarity is IF, which category has only 37 out of 1000 observations in our sample.    
Now we can look at the violin plot with clarity ordered by the median price.  

```{r clarity violin}
diamonds2 %>% ggplot(aes(x = reorder(clarity, price, FUN = median), y = price)) +
  geom_violin(aes(fill = clarity), show.legend = FALSE) +
  geom_boxplot(width = 0.05, fill = "lightblue") +
  labs(title = "Possible effect of clarity on price",
  x = "Clarity",
  y = "Price") +
  coord_flip()
```  

This gives the non-intuitive result that the most desirable category has the lowest price.

### Color
```{r color distribution}
diamonds2 %>% count(color)
```  

```{r color violin}
diamonds2 %>% ggplot(aes(x = reorder(color, price, FUN = median), y = price)) +
  geom_violin(aes(fill = color), show.legend = FALSE) +
  geom_boxplot(width = 0.05, fill = "lightblue") +
  labs(title = "Possible effect of color on price",
       x = "Color",
       y = "Price") +
  coord_flip()
```  

### Cut

```{r cut distribution}
diamonds2 %>% count(cut)
```  

```{r cut violin}
diamonds2 %>% ggplot(aes(x = reorder(cut, price, FUN = median), y = price)) +
  geom_violin(aes(fill = cut), show.legend = FALSE) +
  geom_boxplot(width = 0.1, fill = "lightblue") +
  labs(title = "Possible effect of cut on price",
       x = "Cut",
       y = "Price") +
  coord_flip()
``` 

## Three Potential Problems  
  + Unexpected relationship between price and clarity  
  + Unexpected relationship between price and cut
  + Unequal variance  

## Lurking Variables  

Let's see if size is a lurking or confounding variable for the price versus clarity and price versus cut anomolies.  

### Size by clarity  

```{r size by clarity}
diamonds2 %>% ggplot(aes(x = reorder(clarity, carat, FUN = median), y = carat)) +
  geom_violin(aes(fill = clarity), show.legend = FALSE) +
  geom_boxplot(width = 0.1, fill = "lightblue") +
  labs(title = "Possible effect of clarity on weight",
       x = "Clarity",
       y = "Weight in Carats") +
  coord_flip()
```  

### Size by cut  

```{r size by cut}
diamonds2 %>% ggplot(aes(x = reorder(cut, carat, FUN = median), y = carat)) +
  geom_violin(aes(fill = cut), show.legend = FALSE) +
  geom_boxplot(width = 0.1, fill = "lightblue") +
  labs(title = "Possible effect of cut on weight",
       x = "Cut",
       y = "Weight in Carats") +
  coord_flip()
```  

## Fix the nonconstant variance problem first.    

See if a logarithmic transformation will cause variance to be similar.  

### Natural Log of Price  

```{r log price scatter, message = FALSE}
diamonds2 %>% ggplot(aes(x = carat, y = log(price))) +
  geom_point() +
  geom_smooth()
```  

### Natural Log of Carat  

```{r log carat scatter, message = FALSE}
diamonds2 %>% ggplot(aes(x = log(carat), y = price)) +
  geom_point() +
  geom_smooth()
```    

### Natural Log of Price and Natural Log of Carat  

```{r log log scatter, message = FALSE}
diamonds2 %>% ggplot(aes(x = log(carat), y = log(price))) +
  geom_point() +
  geom_smooth()
```    

## Remove the possible confounding effect of the size of the diamonds by running a simple regression using the natural logarithmic transformations.  

```{r lm to remove weight influence}
model <- lm(log(price) ~ log(carat), data = diamonds2)
```  

### Calculate the residuals and add them to the diamonds2 tibble  

```{r calculate residuals}
diamonds2 <- diamonds2 %>%
  add_residuals(model) %>% 
  mutate(resid = exp(resid))
```  

### Scatterplot of residuals by diamond size  

```{r residual scatterplot, message = FALSE}
diamonds2 %>% ggplot(mapping = aes(x = carat, y = resid)) +
  geom_point() +
  geom_smooth()
```  

### Violin plot of prices by cut after the effect of weight has been removed  

```{r residuals by cut}
diamonds2 %>% ggplot(aes(x = reorder(cut, resid, FUN = median), y = resid)) +
  geom_violin(aes(fill = cut), show.legend = FALSE) +
  geom_boxplot(width = 0.1, fill = "lightblue") +
  labs(title = "Prices with the effect of diamonds weight removed",
       x = "Cut of Diamond",
       y = "Residuals in Dollars") +
  coord_flip()
```  

### Violin plot of prices by clarity after the effect of diamond weight has been removed  

```{r residuals by clarity}
diamonds2 %>% ggplot(aes(x = reorder(clarity, resid, FUN = median), y = resid)) +
  geom_violin(aes(fill = clarity), show.legend = FALSE) +
  geom_boxplot(width = 0.08, fill = "lightblue") +
  labs(title = "Prices with the effect of diamond weight",
       x = "Category",
       y = "Variable") +
  coord_flip()
```    

## Do regression lines by categories share the same intercept and slope?  
### Scatterplots of price on weight for each clarity category.  

```{r regression by clarity, message = FALSE}
diamonds2 %>% ggplot(aes(x = log(carat), y = log(price), color = clarity)) +
  geom_point() +
  geom_smooth(method = "lm")
```    

### Scatterplots of price on weight for each color category.  

```{r regression by color, message = FALSE}
diamonds2 %>% ggplot(aes(x = log(carat), y = log(price), color = color)) +
  geom_point() +
  geom_smooth(method = "lm")
```  

### Scatterplots of price on weight for each cut category.  

```{r regression by cut, message = FALSE}
diamonds2 %>% ggplot(aes(x = log(carat), y = log(price), color = cut)) +
  geom_point() +
  geom_smooth(method = "lm")
```  

## Prediction of diamond prices  

### Fit the prediction model using multiple regression  

We can predict a diamonds price by fitting a linear model that includes the effects of weight, clarity, color, and cut.

```{r prediction model}
model <- lm(log(price) ~ log(carat) + clarity + color + cut + cut * log(carat),
            data = diamonds2)
model %>% summary()
model %>% anova()
```  

### Predict price of diamonds  

The purpose of this analysis is to predict a diamond's price based on its weight, clarity, color, and cut. We use the previous regression now to predict the price.

```{r forecasts}
carat <- 1
clarity <- "IF"
color <- "J"
cut <- "Ideal"

new_data <- data.frame(carat, cut, color, clarity)
predict(object = model, newdata = new_data, interval = "predict") %>% exp()
```  



