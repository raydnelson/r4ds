# Iteration
# Initial: 12 Oct 2018
# Revision: 16 Oct 2018
# Ray Nelson

# Libraries
library(tidyverse)
library(broom)

# 21.2 For loops ---------------------------------------------------------------

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df[[1]]

median(df$a)
median(df$b)
median(df$c)
median(df$d)

output <- vector("double", ncol(df))  #1. Output
for (i in seq_along(df)) {            #2. Sequence
  output[[i]] <- median(df[[i]])      #3. Body
}
output

seq_along(df)
y <- vector("double", 0)
seq_along(y)
1: length(y)

# 21.3 For loop variations -----------------------------------------------------
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

# 21.3.1 Modifying an existing object

rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)

for (i in seq_along(df)) {
  df[[i]] <- rescale01(df[[i]])
}

# 21.3.2 Looping patterns

(results <- vector("list", length(x)))
names(results) <- names(df)
results

## Looping with an index

for (i in seq_along(x)) {
  name <- names(x)[[i]]
  # print(name)
  value <- x[[i]] %>% mean() %>% round(2)
  paste("The mean of ", name, "is: ", value) %>% print()
}

## looping over elements
df_names <- c("a", "b", "c", "d")
for (nm in df_names) {
  value <- x[[nm]] %>% mean() %>% round(2)
  paste("The mean of ", name, "is: ", value) %>% print()
}

## Looping over names
for (nm in names(x)) {
  means <- x[[nm]] %>% mean %>% round(2)
  paste("The mean of ", nm, "is: ", means) %>% print()
}

#21.3.2 Unknown output length
means <- c(0, 1, 2)

# Progressive growing of vector
output <- double()
for (i in seq_along(means)) {
  n <- sample(100, 1)
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)

# Explicit declaration of output size

out <- vector("list", length(means))
for (i in seq_along(means)) {
  n <- sample(100, 1)
  out[[i]] <- rnorm(n, means[[i]])
}
str(out)

str(unlist(out))

# 21.3.4 Unknown sequence length

## Coin flip example

flip <- function() sample(c("T", "H"), 1)

flips <- 0
nheads <- 0

while (nheads < 3) {
  if (flip() == "H") {
    nheads <- nheads + 1
  } else {
    nheads <- 0
  }
  flips <- flips + 1
}
flips


## Function
sample(c("T", "H"), 4, replace = TRUE) %>% 
  table()

flip <- function() sample(c("T", "H"), 1)

trial <- function() {
  flips <- 0
  nheads <- 0
  
  while (nheads < 3) {
    if (flip() == "H") {
      nheads <- nheads + 1
    } else {
      nheads <- 0
    }
    flips <- flips + 1
  }
  flips
}

# Run the above experiment 10 times

trials <- vector("integer", 10)

for (i in seq_along(trials)) {
  trials[[i]] <- trial()
}

trials

# 21.4 For loops vs. functionals -----------------------------------------------

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

output <- vector("double", length(df))
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]])
}
output

col_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  output
}

df %>% col_mean()

col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}

col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}

f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3

f <- function(x, i) abs(x - mean(x)) ^ i

col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}
col_summary(df, mean)
col_summary(df, median)
col_summary(df, sd)

# 21.5 The map functions -------------------------------------------------------
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)

df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)

map_dbl(df, mean, trim = 0.5)

z <- list(x = 1:3, y = 4:5)
map_int(z, length)

# 21.5.1 Shortcuts

## What are the possible values for cyl
mtcars %>% 
  count(cyl)

models <- mtcars %>% 
  split(.$cyl) %>% 
  map(function(df) lm(mpg ~ wt, data = df))

models <- mtcars %>% 
  split(.$cyl) %>% 
  map(~lm(mpg ~ wt, data = .))

models %>% 
  map(summary) %>% 
  map_dbl(~.$r.squared)

models %>% 
  map(summary) %>% 
  map_dbl("r.squared")

# You can also use integer to extract by position

x <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))
x %>% map_dbl(2)

# 21.5.2 Base R

## The apply functions

mtcars %>% apply(2, mean)
mtcars %>% apply(1, mean)

x1 <- list(
  c(0.27, 0.37, 0.57, 0.91, 0.20),
  c(0.90, 0.94, 0.66, 0.63, 0.06), 
  c(0.21, 0.18, 0.69, 0.38, 0.77)
)

x2 <- list(
  c(0.50, 0.72, 0.99, 0.38, 0.78), 
  c(0.93, 0.21, 0.65, 0.13, 0.27), 
  c(0.39, 0.01, 0.38, 0.87, 0.34)
)

threshold <- function(x, cutoff = 0.8) x[x > cutoff]

x1 %>% lapply(threshold) %>% str()
x2 %>% lapply(threshold) %>% str()


# 21.6 Dealing with failure ----------------------------------------------------

safe_log <- safely(log)
str(safe_log(10))

safe_log("a") %>% str()


x <- list(1, 10, "a")
y <- x %>% 
  map(safely(log))
y %>% str()

y <- y %>% 
  transpose()
y %>% str()

is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]

y$result[is_ok] %>% flatten_dbl()

x <- list(1, 10, "a")
x %>% map_dbl(possibly(log, NA_real_))

x <- list(1, -1)
x %>% map(quietly(log)) %>% str()

# 21.7 Mapping over multiple arguments -----------------------------------------

mu <- list(5, 10, -3)
mu %>% 
  map(rnorm, n = 5) %>% 
  str()

sigma <- list(1, 5, 10)
seq_along(mu) %>% 
  map(~rnorm(5, mu[[.]], sigma[[.]])) %>% 
  str()

map2(mu, sigma, rnorm, n = 5) %>% str()

n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>% str()

args1 %>% 
  pmap(rnorm) %>% 
  str()

args2 <- list(mean = mu, sd = sigma, n = n)
args2 %>% 
  pmap(rnorm) %>% 
  str()

params <- tribble(
  ~mean, ~sd, ~n,
  5,     1,  1,
  10,     5,  3,
  -3,    10,  5
)
params %>% 
  pmap(rnorm)

f <- c("runif", "rnorm", "rpois")
param <- list(
  list(min = -1, max = 1),
  list(sd = 5),
  list(lambda = 10)
)

invoke_map(f, param, n = 5) %>% str()

sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)
sim %>% 
  mutate(sim = invoke_map(f, params, n = 10))

# 21.8 Walk --------------------------------------------------------------------

x <- list(1, "a", 3)

x %>% 
  walk(print)

plots <- mtcars %>% 
  split(.$cyl) %>% 
  map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf")

pwalk(list(paths, plots), ggsave, path = tempdir())

# 21.9 Other patterns of for loops ---------------------------------------------

iris %>%
  str()

iris %>% 
  keep(is.factor) %>% 
  str()

iris %>% 
  discard(is.factor) %>% 
  str()

x <- list(1:5, letters, list(10))

x %>% 
  some(is_character)

x %>% 
  every(is_vector)

(x <- sample(10))

x %>% 
  detect(~ . > 5)

x %>% 
  detect_index(~ . > 5)

x %>% 
  head_while(~ . > 5)

x %>% 
  tail_while(~ . > 5)

dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),
  trt = tibble(name = "Mary", treatment = "A")
)

# 21.9.2 Reduce and accumulate

## Combine multiple tibbles into one
dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),
  trt = tibble(name = "Mary", treatment = "A")
)

dfs %>% reduce(full_join)

## Find the intersection of multiple vectors
vs <- list(
  c(1, 3, 5, 6, 10),
  c(1, 2, 3, 7, 8, 10),
  c(1, 2, 3, 4, 8, 9, 10)
)
vs %>% reduce(intersect)

## Accumulate can be used to give a cumulative sum
(x <- sample(10))
x %>% accumulate(`+`)