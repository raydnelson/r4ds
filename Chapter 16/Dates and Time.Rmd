---
title: "Dates and Times"
author: "MPA 634: Data Science for Managers"
date: "2 March 2020"
output:
  html_document:
    code_folding: "hide"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Load libraries
library(tidyverse)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
library(lubridate)
library(nycflights13)
```

## 16.2 Creating date/times  

Three types of date/time data  

*  A date, which tibbles print as "date"
*  A time, which tibbles print as "time"
*  A date-time, which tibbles as "dttm" and else where in R as POSIXct 

Functions that give the current day and the current date-time are:

```{r current day and date-time functions}
today()
now()
```  

Creation of date/time:  

*  From a string
*  From individual date-time components
*  From an existing date/time object  

### 16.2.1 From Strings

The default for R is year-month-day. All three of the following functions give the same date.  

```{r from strings}
ymd("2019-02-28")
ymd(20190218)
mdy("February 28, 2019")
dmy("28-Feb-2019")
```  

Create date-time by adding and underscore and "h", "m", and "s".  

```{r create date-time from strings}
ymd_hms("2019-02-28 13:12:30", tz = "MST")
mdy_hm("2-28-2019 13:13", tz = "MST")
```

### 16.2.2 From individual components  

```{r from individual components}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(depature = make_datetime(year, month, day, hour, minute))
```  

As we have done previously, we need to convert dep_time, sched_dep_time, arr_time, and sched_arr_time into time formats. Since we will do this repeatedly, we write a function.  

```{r construct data-times out of numbers}
make_datetime_100 <- function(year, month, day, time){
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>%
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt %>% print()
```

### Departures by day for the year. The number of seconds in a day is 24 * 60 * 60 = 86400 seconds. 

```{r daily departures}
flights_dt %>% 
  ggplot(aes(dep_time)) +
  geom_freqpoly(binwidth = 86400)
```  

### Departures in a single day. The number of seconds in 10 minutes is 10 * 60 = 600 seconds. Choose January 1, 2013 as the day

```{r intra day departures}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) +
  geom_freqpoly(binwidth = 600)
```  

### 16.2.3 From other types  

```{r time-dates from other types}
today() %>% as_datetime()
now() %>% as_date()
as_datetime(60 * 60 * 10) # Should give us 10 o'clock
as_date(365 * 10 + 2)
```

## 16.3 Date-time components  

### 16.3.1 Getting components

```{r getting components}
datetime <- ymd_hms("2019-03-04 12:15:30")

datetime %>% year()
datetime %>% month()
datetime %>% mday()
datetime %>% yday()
datetime %>% wday()

datetime %>% month(label = TRUE)
datetime %>% wday(label = TRUE, abbr = FALSE)
```  

Let's calculate and graph the number of flights that depart on each day of the week.  

```{r flights on each day of the week}
flights_dt %>% 
  mutate(weekday = wday(sched_dep_time, label = TRUE)) %>% 
  ggplot(aes(x = weekday, fill = weekday)) +
  geom_bar(show.legend = FALSE) +
  labs(
    title = "Weekends have fewer departures.",
    subtitle = "NYC Flights during 2013",
    x = "",
    y = "Number of Flights"
  )
```  

There is an interesting pattern for the average delay of departures during the hour. This is a graph of each minute in the hour of departure times and the average departure delay. 

```{r hourly pattern of delays relative to actual departure time}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    average_delay = mean(dep_delay, na.rm = TRUE)
  ) %>% 
  ggplot(aes(minute, average_delay)) +
  geom_line() +
  labs(
    title = "There is a definite pattern in average delays relative to the hour of the day.",
    x = "Minutes from Actual Departure Time",
    y = "Average Departure Delay in Minutes"
  )
```  

The pattern doesn't seem to exist when we look at the schedule departures.  

```{r hourly pattern of delays relative to scheduled departure time}
flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    average_delay = mean(dep_delay, na.rm = TRUE)
  ) %>% 
  ggplot(aes(minute, average_delay)) +
  geom_line() +
  labs(
    title = "The average delay doesn't have as strong a pattern with the hour of the day.",
    x = "Minutes from Scheduled Departure Time",
    y = "Average Departure Delay in Minutes"
  )
```  

The number of flights schedule for each minute of the hour does generate an interesting pattern.

```{r number of flights departing from NYC airports by minute of the hour}
flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    number_of_flights = n()
  ) %>% 
  ggplot(aes(minute, number_of_flights / 1000)) +
  geom_line(color = "blue") +
  labs(
    title = "Some minutes in the hour are more popular than others for scheduled departures.",
    x = "Minutes in Each Hour of Day of Scheduled Departurers",
    y = "Number of Flights (Thousands)"
  ) +
  scale_x_continuous(breaks = seq(0, 60, 5), labels = seq(0, 60, 5))
```  

16.3.2 Rounding  

Rounding can give us the number of flights in a week.  

```{r flights in a week}
flights_dt %>%
  mutate(
    week = floor_date(dep_time, "week")
  ) %>% 
  count(week) %>% 
  ggplot(aes(week, n)) +
  geom_line()
```

16.3.3 Setting components using the accessor functions

```{r setting components}
(datetime <- ymd_hms("2019-03-04 12:15:00"))

(year(datetime) <- 2020)


(month(datetime) <- 01)

(hour(datetime) <- hour(datetime) + 1)

(datetime <- update(datetime, year = 2020, month = 2, mday = 2, hour = 2))
```
When values are too large then they roll over.  

```{r overflow}
ymd("2019-02-01") %>% 
  update(mday = 31)

ymd("2019-02-01") %>% 
  update(hours = 400)
```  

Use update to show the distribution of fights across the course of the day for every day of the year.

```{r distribution of flights over the course of a day}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
  geom_freqpoly(binwidth = 300)
```  

