---
title: "Final Exam Winter 2019"
author: "Data Science for Managers"
date: "Due by midnight: 4/24/2019"
output:
  html_document:
    code_folding: "show"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

Submit an R Markdown file for the following four problems. In order to get full credit, your R Markdown document must knit properly and you shouldn't use any software other than R to complete your calculations.    

## Problem 1 Violin Plot

Create the following violin plot for the hwy and cty variables from the mpg tibble.

```{r Problem 1}
mpg %>% 
  select(hwy, cty) %>% 
  gather(key = "Type_of_Driving", value = "Miles_Per_Gallon") %>% 
  ggplot(aes(Type_of_Driving, Miles_Per_Gallon, fill = Type_of_Driving)) +
  geom_violin(show.legend = FALSE) +
  geom_boxplot(fill = "grey", width = 0.25, show.legend = FALSE) +
  coord_flip() +
  labs(
    title = "Highway driving has higher mileage but more variation.",
    subtitle = "MPG tibble from the tidyverse library.",
    x = "Type of Driving",
    y = "Miles Per Gallon",
    caption = "Only models with new releases between 1999 and 2008."
  )
```

## Problem 2 Linear models with different slopes and intercepts  

Estimate a linear model with price as the response variable and cut and carat from the diamonds tibble as explanatory or predictor variables. Use only a subset of 1,000 observations to complete the following:

1.  Use ggplot to investigate whether linear models for each different type of diamond cut have different slopes and intercepts. Your plot should look like the one given below.
2.  Estimate a linear model with price as the response variable and carat and cut as explanatory variables. Your model should generate different slopes and intercepts for each cut of diamond.  
3.  Use your estimated model to predict the price of a diamond that weighs 0.6 carats and has an ideal cut. Round your prediction to the nearest ten dollars.  

```{r problem 2, message=FALSE}
set.seed(1234)
diamonds %>% 
  sample_n(1000) %>% 
  ggplot(aes(carat, price, color = cut)) +
  geom_point(show.legend = FALSE) +
  geom_smooth(method = "lm", show.legend = FALSE) +
  facet_grid(rows = vars(cut))

diamonds_lm <- lm(price ~ cut + carat + cut * carat, data = diamonds)

new_data <- tibble(carat = 0.6, cut = "Ideal")
diamonds_lm %>% predict(newdata = new_data) %>% round(digits = -1)
```

## Problem 3 Correlation as the covariance between two z-scores

1.  Write a function called Correlation that calculates the correlation as the covariance between two z-scores.
2.  Compare the result of your function with the base R function cor. Test your function using the hwy and cty variables from the mpg tibble.  

Here are the comparisons (rounded to two decimal places) that we calculated:  

```{r Problem 3}
Correlation <- function(x, y) {
  x <- scale(x)
  y <- scale(y)
  cov(x,y)
}

Correlation(mpg$hwy, mpg$cty) %>% round(2)
cor(mpg$hwy, mpg$cty) %>% round(2)
```

## Problem 4 Iteration, z-scores, and outliers    

Often times we can identify outliers by looking at z-scores.  

1.  Write a function that identifies the size of the most deviant observations as defined by the largest absolute value of the z-score.
2.  Create a new tibble that includes only the numerical columns from mpg.  
3.  Use a for loop and your function to find the most deviant z-score for each numerical column in the mpg tibble.
4.  Print out your z-scores.

Here are the rounded z-scores that we got for the displ, cty, and hwy variables:  

```{r Problem 4}
most_deviant <- function(x) {
  scale(x) %>% abs() %>% max()
}

mpg_numeric <- mpg %>% 
  select(displ, cty, hwy)

deviant_values <- vector("numeric", length(mpg_numeric))
for (i in seq_along(mpg_numeric)) {
  deviant_values[[i]] <- mpg_numeric[[i]] %>% most_deviant()
}

tibble(variables = colnames(mpg_numeric), z_scores = deviant_values %>% round(2))
```